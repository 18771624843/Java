#34.Java中的强软弱虚引用及其应用

##34.1 强引用（Strong References）

强引用是使用最频繁的引用。例如：
```Java
Object obj = new Object();
```
如果一个对象有强引用，则垃圾回收器不会回收它。即使JVM内存不足，也是抛出`OutOfMemeoryError`来停止程序，也不会通过回收强引用来释放内存。

##34.2 软引用（Soft Reference）

如果一个对象只有软引用，则在JVM足够时该对象不会被回收，而当JVM不足时就会回收该对象释放内存。

```Java
SoftReference<Object> obj = new SoftReference<Object>(new Object());
```

软引用最常用的应用场景就是用来做缓存。

##35.3 弱引用（Weak Reference）

只具有弱引用的对象，在下一轮GC时，不管JVM内存足够不足够，都会对它进行回收。

```Java
WeakReference<Object> obj = new WeakReference<Object>(new Object());
```

##35.5 幽灵引用（Phantom Reference）

**幽灵引用**又叫**虚引用**。 幽灵引用十分诡异，因为它的get()方法永远只返回null。

```Java
PhantomReference<Object> obj = new PhantomReference<Object>(new Object(), new ReferenceQueue<Object>());

System.out.println(obj.get());  //null
```
幽灵引用有什么用？

##35.6 强可达、软可达，弱可达，虚可达

* **强可达（Strongly Reachable）** – If we have a strong reference to a particular instance, then it is said to be strongly reachable. Hence, it is not eligible for garbage collection.
* **软可达（Softly Reachable）** – If we do not have a strong reference to an instance, but we can access the object through a SoftReference (more on that later) to it, then the instance is said to be softly reachable.
* **弱可达（Weakly Reachable）** – If we have neither a strong reference nor a soft reference, but the object can be accessed through a WeakReference, then the instance is said to be weakly reachable.
* **幽灵可达（Phantomly Reachable）** – If we don’t have any of the strong, soft or weak references to a particular instance (which has not been finalized), but, if we do have a PhantomReference (explained in a while) to the instance, then the instance is said to be phantomly reachable.
* **不可达（Unreachable）** – If we do not have any of the above references to an instance, then it is unreachable from the program.


http://blog.yohanliyanage.com/2010/10/ktjs-3-soft-weak-phantom-references/ 
