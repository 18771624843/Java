#06.Java NIO选择器

选择器（Selector）是Java NIO中的一个组件，它用于检测一个或多个通道，并确定哪些通道可以进行读、写。这就是为什么Java NIO中可以使用单个线程对多个通道或网络连接进行管理。


##为何要使用选择器（Why Use a Selector?）

使用选择器的优势在于：**使用单个线程就可以对多个管道进行操作，从而可以减少处理通道的线程数量**。实际上，你可以仅仅使用一个线程来处理所有的通道。在操作系统中，线程的切换是非常昂贵的，并且，每个线程需要消耗一定的系统资源（例如内存）。因此，线程使用越少越好。

不过，随着操作系统软硬件的更新迭代，多线程的开销越来越小，性能也越来越优异。而事实上，如果计算机拥有多个CPU内核，这时候如果不采用多线程，反而是对CPU资源的浪费。然而，这已不属于本教程讨论的范畴。

下面的图片描绘了如何使用一个选择器来处理3个通道：

![Java NIO: A Thread uses a Selector to handle 3 Channel's](http://tutorials.jenkov.com/images/java-nio/overview-selectors.png)

##创建选择器（Creating a Selector）

可以通过`Selector.open()`方法来创建选择器：

```Java
Selector selector = Selector.open();
```

#Registering Channels with the Selector

为了让选择器能够处理通道，必须向选择器注册需要处理的通道，调用`SelectableChannel.register()`方法来完成注册：

```
channel.configureBlocking(false);

SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
```

注册的通道必须先设置为**非阻塞模式（non-blocking mode）**。由于**FileChannel**不能设置为非阻塞模式，所以FileChannel不能进行注册，而**SocketChanne**l则可以。

注意`SelectableChannel.register()`方法的第二个参数。这个参数代表着**选择器需要监听通道的事件类型**。总共有四种不同的事件类型：

通道**触发一个事件**，我们称之为**事件就绪**。所以，如果通道跟远程服务器建立了连接，称之为**连接就绪**；服务器socket接受客户端连接，称为**接收就绪**；通道中有数据可读，称为**读就绪**，可向通道中写数据，称为**写就绪**。

以上四个事件分别由`SelectionKey`类中的四个常量来表示：

```Java
SelectionKey.OP_CONNECT
SelectionKey.OP_ACCEPT
SelectionKey.OP_READ
SelectionKey.OP_WRITE
```

如果需要监听多个事件，可以使用OR操作符：

```Java
int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;   
```
由于SelectionKey中是四个常量OP\_READ、OP\_WRITE、OP\_CONNECT、OP\_ACCEPTF分别用二进制0001、0010、0100、1000表示，所以可以通过interestSet中的二进制判断监听的事件类型。

##SelectionKey's

As you saw in the previous section, when you register a Channel with a Selector the register() method returns a SelectionKey objects. This SelectionKey object contains a few interesting properties:

The interest set
The ready set
The Channel
The Selector
An attached object (optional)
I'll describe these properties below.

###Interest Set

The interest set is the set of events you are interested in "selecting", as described in the section "Registering Channels with the Selector". You can read and write that interest set via the SelectionKey like this:

int interestSet = selectionKey.interestOps();

boolean isInterestedInAccept  = interestSet & SelectionKey.OP_ACCEPT;
boolean isInterestedInConnect = interestSet & SelectionKey.OP_CONNECT;
boolean isInterestedInRead    = interestSet & SelectionKey.OP_READ;
boolean isInterestedInWrite   = interestSet & SelectionKey.OP_WRITE;    
As you can see, you can AND the interest set with the given SelectionKey constant to find out if a certain event is in the interest set.

###Ready Set

The ready set is the set of operations the channel is ready for. You will primarily be accessing the ready set after a selection. Selection is explained in a later section. You access the ready set like this:

int readySet = selectionKey.readyOps();
You can test in the same way as with the interest set, what events / operations the channel is ready for. But, you can also use these four methods instead, which all reaturn a boolean:

selectionKey.isAcceptable();
selectionKey.isConnectable();
selectionKey.isReadable();
selectionKey.isWritable();
Channel + Selector

Accessing the channel + selector from the SelectionKey is trivial. Here is how it's done:

Channel  channel  = selectionKey.channel();

Selector selector = selectionKey.selector();    
Attaching Objects

You can attach an object to a SelectionKey this is a handy way of recognizing a given channel, or attaching further information to the channel. For instance, you may attach the Buffer you are using with the channel, or an object containing more aggregate data. Here is how you attach objects:

selectionKey.attach(theObject);

Object attachedObj = selectionKey.attachment();
You can also attach an object already while registering the Channel with the Selector, in the register() method. Here is how that looks:

SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);
Selecting Channels via a Selector

Once you have register one or more channels with a Selector you can call one of the select() methods. These methods return the channels that are "ready" for the events you are interested in (connect, accept, read or write). In other words, if you are interested in channels that are ready for reading, you will receive the channels that are ready for reading from the select() methods.

Here are the select() methods:

int select()
int select(long timeout)
int selectNow()
select() blocks until at least one channel is ready for the events you registered for.

select(long timeout) does the same as select() except it blocks for a maximum of timeout milliseconds (the parameter).

selectNow() doesn't block at all. It returns immediately with whatever channels are ready.

The int returned by the select() methods tells how many channels are ready. That is, how many channels that became ready since last time you called select(). If you call select() and it returns 1 because one channel has become ready, and you call select() one more time, and one more channel has become ready, it will return 1 again. If you have done nothing with the first channel that was ready, you now have 2 ready channels, but only one channel had become ready between each select() call.

selectedKeys()

Once you have called one of the select() methods and its return value has indicated that one or more channels are ready, you can access the ready channels via the "selected key set", by calling the selectors selectedKeys() method. Here is how that looks:

Set<SelectionKey> selectedKeys = selector.selectedKeys();    
When you register a channel with a Selector the Channel.register() method returns a SelectionKey object. This key represents that channels registration with that selector. It is these keys you can access via the selectedKeySet() method. From the SelectionKey.

You can iterate this selected key set to access the ready channels. Here is how that looks:

Set<SelectionKey> selectedKeys = selector.selectedKeys();

Iterator<SelectionKey> keyIterator = selectedKeys.iterator();

while(keyIterator.hasNext()) {
    
    SelectionKey key = keyIterator.next();

    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.

    } else if (key.isConnectable()) {
        // a connection was established with a remote server.

    } else if (key.isReadable()) {
        // a channel is ready for reading

    } else if (key.isWritable()) {
        // a channel is ready for writing
    }

    keyIterator.remove();
}
This loop iterates the keys in the selected key set. For each key it tests the key to determine what the channel referenced by the key is ready for.

Notice the keyIterator.remove() call at the end of each iteration. The Selector does not remove the SelectionKey instances from the selected key set itself. You have to do this, when you are done processing the channel. The next time the channel becomes "ready" the Selector will add it to the selected key set again.

The channel returned by the SelectionKey.channel() method should be cast to the channel you need to work with, e.g a ServerSocketChannel or SocketChannel etc.

###wakeUp()

A thread that has called the select() method which is blocked, can be made to leave the select() method, even if no channels are yet ready. This is done by having a different thread call the Selector.wakeup() method on the Selector which the first thread has called select() on. The thread waiting inside select() will then return immediately.

If a different thread calls wakeup() and no thread is currently blocked inside select(), the next thread that calls select() will "wake up" immediately.

###close()

When you are finished with the Selector you call its close() method. This closes the Selector and invalidates all SelectionKey instances registered with this Selector. The channels themselves are not closed.

##Full Selector Example

Here is a full example which opens a Selector, registers a channel with it (the channel instantiation is left out), and keeps monitoring the Selector for "readiness" of the four events (accept, connect, read, write).

Selector selector = Selector.open();

channel.configureBlocking(false);

SelectionKey key = channel.register(selector, SelectionKey.OP_READ);


while(true) {

  int readyChannels = selector.select();

  if(readyChannels == 0) continue;


  Set<SelectionKey> selectedKeys = selector.selectedKeys();

  Iterator<SelectionKey> keyIterator = selectedKeys.iterator();

  while(keyIterator.hasNext()) {

    SelectionKey key = keyIterator.next();

    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.

    } else if (key.isConnectable()) {
        // a connection was established with a remote server.

    } else if (key.isReadable()) {
        // a channel is ready for reading

    } else if (key.isWritable()) {
        // a channel is ready for writing
    }

    keyIterator.remove();
  }
}