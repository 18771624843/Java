##25.1 JCA介绍
**JCA**是**Java密码系统结构**（Java Cryptography Architecture）的简称。JCA提供了一系列的用于数字签名、消息摘要（哈希）、证书管理、证书验证、加密解密（对称/非对称/流），密钥生成/管理、安全随机数等的接口。它提供了一种称为**"provider"**的方式来让开发者添加加密解密的算法实现或自定义实现，类似于JDBC。**provider**的好处在于：

* **算法实现独立：** Applications do not need to implement security algorithms. Rather, they can request security services from the Java platform. Security services are implemented in providers (see below), which are plugged into the Java platform via a standard interface. An application may rely on multiple independent providers for security functionality.
* **实现互操作：** Providers are interoperable across applications. Specifically, an application is not bound to a specific provider, and a provider is not bound to a specific application.
* **可拓展算法：** The Java platform includes a number of built-in providers that implement a basic set of security services that are widely used today. However, some applications may rely on emerging standards not yet implemented, or on proprietary services. The Java platform supports the installation of custom providers that implement such services.

for digital signatures, message digests (hashes), certificates and certificate validation, encryption (symmetric/asymmetric block/stream ciphers), key generation and management, and secure random number generation, to name a few. 
##25.1 JCA Concepts
This section introduces the major JCA APIs.

Engine Classes and Algorithms
An engine class provides the interface to a specific type of cryptographic service, independent of a particular cryptographic algorithm or provider. The engines either provide:

cryptographic operations (encryption, digital signatures, message digests, etc.),
generators or converters of cryptographic material (keys and algorithm parameters), or
objects (keystores or certificates) that encapsulate the cryptographic data and can be used at higher layers of abstraction.
The following engine classes are available:

* SecureRandom: used to generate random or pseudo-random numbers.
* MessageDigest: used to calculate the message digest (hash) of specified data.
* Signature: initialized with keys, these are used to sign data and verify digital signatures.
* Cipher: initialized with keys, these used for encrypting/decrypting data. There are various types of algorithms: symmetric bulk encryption (e.g. AES, DES, DESede, Blowfish, IDEA), stream encryption (e.g. RC4), asymmetric encryption (e.g. RSA), and password-based encryption (PBE).
* Message Authentication Codes (MAC): like MessageDigests, these also generate hash values, but are first initialized with keys to protect the integrity of messages.
* KeyFactory: used to convert existing opaque cryptographic keys of type Key into key specifications (transparent representations of the underlying key material), and vice versa.
* SecretKeyFactory: used to convert existing opaque cryptographic keys of type SecretKey into key specifications (transparent representations of the underlying key material), and vice versa. SecretKeyFactorys are specialized KeyFactorys that create secret (symmetric) keys only.
* KeyPairGenerator: used to generate a new pair of public and private keys suitable for use with a specified algorithm.
* KeyGenerator: used to generate new secret keys for use with a specified algorithm.
* KeyAgreement: used by two or more parties to agree upon and establish a specific key to use for a particular cryptographic operation.
* AlgorithmParameters: used to store the parameters for a particular algorithm, including parameter encoding and decoding.
* AlgorithmParameterGenerator : used to generate a set of AlgorithmParameters suitable for a specified algorithm.
* KeyStore: used to create and manage a keystore. A keystore is a database of keys. Private keys in a keystore have a certificate chain associated with them, which authenticates the corresponding public key. A keystore also contains certificates from trusted entities.
* CertificateFactory: used to create public key certificates and Certificate Revocation Lists (CRLs).
* CertPathBuilder: used to build certificate chains (also known as certification paths).
* CertPathValidator: used to validate certificate chains.
* CertStore: used to retrieve Certificates and CRLs from a repository.

**NOTE:** A generator creates objects with brand-new contents, whereas a factory creates objects from existing material (for example, an encoding).

##25.2 参考资料
* http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html
* http://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html