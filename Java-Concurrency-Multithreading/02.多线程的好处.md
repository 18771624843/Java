#02.多线程的好处

尽管多线程带来的一些挑战，也让先写应用程序变得复杂，但它也带来了一系列好处：

* 更好的资源利用率
* 在某些情况下，让程序变得更加简单
* More responsive programs


##更好的资源利用率（Better resource utilization）

试想一下，一个读取和处理本地系统文件的应用程序。比方说，从磁盘读取AF文件需要5秒，处理需要2秒，处理两个文件过程如下：

```
读取文件A消耗5s
处理文件A消耗2s
读取文件B消耗5s
处理文件B消耗2s
-------------
总共消耗时间14s
```

当从磁盘读取文件时，大部分的CPU时间都消耗在了等待磁盘读取数据，而在这段时间内，CPU大部分时间内都是空闲的，它原本可以用来做其他操作。改变操作的顺序，可以让CPU得到更高的利用率。如下所示：

```
读取文件A消耗5s
读取文件B消耗5s + 处理文件A消耗2s
处理文件B消耗2s
-------------
总共消耗时间12s
```

当CPU读取往文件A后，则紧随着读取文件B，在此同时处理文件A。需要谨记的是，在等带磁盘读取文件时，CPU大部分时间都是空闲的。

一般来说，在CPU等待IO操作时可以处理其他任务。IO操作可以是磁盘IO，网络IO或者用户的输入。磁盘IO和网络IO远远慢于CPU IO和内存IO。


##Simpler Program Design

If you were to program the above ordering of reading and processing by hand in a singlethreaded application, you would have to keep track of both the read and processing state of each file. Instead you can start two threads that each just reads and processes a single file. Each of these threads will be blocked while waiting for the disk to read its file. While waiting, other threads can use the CPU to process the parts of the file they have already read. The result is, that the disk is kept busy at all times, reading from various files into memory. This results in a better utilization of both the disk and the CPU. It is also easier to program, since each thread only has to keep track of a single file.

##More responsive programs

Another common goal for turning a singlethreaded application into a multithreaded application is to achieve a more responsive application. Imagine a server application that listens on some port for incoming requests. when a request is received, it handles the request and then goes back to listening. The server loop is sketched below:

 
  while(server is active){
    listen for request
    process request
  }
If the request takes a long time to process, no new clients can send requests to the server for that duration. Only while the server is listening can requests be received.

An alternate design would be for the listening thread to pass the request to a worker thread, and return to listening immediatedly. The worker thread will process the request and send a reply to the client. This design is sketched below:

 
  while(server is active){
    listen for request
    hand request to worker thread
  }
This way the server thread will be back at listening sooner. Thus more clients can send requests to the server. The server has become more responsive.

The same is true for desktop applications. If you click a button that starts a long task, and the thread executing the task is the thread updating the windows, buttons etc., then the application will appear unresponsive while the task executes. Instead the task can be handed off to a worker thread. While the worker thread is busy with the task, the window thread is free to respond to other user requests. When the worker thread is done it signals the window thread. The window thread can then update the application windows with the result of the task. The program with the worker thread design will appear more responsive to the user.

