#22.编码解码

在JVM内部，数据总是以unicode码的形式与JVM虚拟机交互，然而当数据需要输出到系统外部时，例如输出到控制台，数据就会转为具体的编码格式进行输出。

```Java
System.out.println("中国");
```
1. 无论文件以任何编码格式载入到JVM中，"中国"二字都会以unicode码的形式存在JVM中（\u4e2d\u56fd）；
2. 假如IDE控制台的编码为UTF-8，当对"中国"二字进行控制台输出时，系统会将unicode码转为具体的UTF-8编码格式。（\u4e2d\u56fd -> e4b8ade59bbd）

```
  "d6d0b9fa"  (GBK编码格式数据)
     ↓ 将数据已GBK格式转为Unicode码载入JVM中
  "\u4e2d\u56fd"  (数据的unicode码表示)
     ↓ 将unicode码转为UTF-8格式数据输出到控制台
  "e4b8ade59bbd"
``` 

一旦数据载入JVM中，就以unicode码的形式存在JVM中，此时并没有具体的编码格式，这时，你可以将数据转为任意编码格式。

```Java
public class Test {
	public static void main(String[] args) throws UnsupportedEncodingException {
	    /**
	     * 数据以unicode码的形式载入JVM中，此时你可以将其转为任意编码格式
	     */
		String str = "中国";
		System.out.println(toHexString(str.getBytes()));  // e4b8ade59bbd  系统默认UTF-8
		System.out.println(toHexString(str.getBytes("GBK"))); // d6d0b9fa GB2312
		System.out.println(toHexString(str.getBytes("GB2312"))); // d6d0b9fa GBK
		System.out.println(toHexString(str.getBytes("UTF-8"))); // e4b8ade59bbd UTF-8
		System.out.println(toHexString(str.getBytes("UTF-16"))); // feff4e2d56fd UTF-16
	}

	public static String toHexString(byte[] data) {
		final int l = data.length;
		final char[] out = new char[l << 1];

		for (int i = 0, j = 0; i < l; i++) {
			out[j++] = DIGITS_LOWER[(0xF0 & data[i]) >>> 4];
			out[j++] = DIGITS_LOWER[(0x0F & data[i])];
		}

		return new String(out);
	}

	final static char[] DIGITS_LOWER = { '0', '1', '2', '3', '4', '5', '6',
			'7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
}
```
有人说，当读取文件的编码格式是GBK时，系统对数据进行输出时也需要相应的GBK编码格式，其实这是错误的理解，因为当数据载入JVM时就自动转为unicode码了，所以当你对其进行输出时，可以采取任意编码。打个比方，web系统从数据库获取GBK格式的数据，然后将其以UTF-8的格式输出到web页面，这是完全没有问题的。


```java
public class GetBytesTest {
	@Test
	public void t4() {
		String s = "曾";
		System.out.println(toHexString(s.getBytes()));
		System.out.println(Hex.encodeHexString(s.getBytes()));
	}

	public static String toHexString(byte[] data) {
		final int l = data.length;
		final char[] out = new char[l << 1];

		for (int i = 0, j = 0; i < l; i++) {
			out[j++] = DIGITS_LOWER[(0xF0 & data[i]) >>> 4];
			out[j++] = DIGITS_LOWER[(0x0F & data[i])];
		}

		return new String(out);
	}

	final static char[] DIGITS_LOWER = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
}

```
