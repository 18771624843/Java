#29.Java8之Stream
在动态语言中，操作集合是一个非常方便的事情。例如以下的JavaScript代码：
```JavaScript
var list = [0,1,2,3,4,5,6,7,8,9];
var rs = list.filter(function(i){return i % 2 == 0;}).map(function(i){return i * i;}).sort(function(x,y){return x < y;})
```
以上JavaScript代码执行结果为：
> [64, 36, 16, 4, 0]

而同样的功能使用Java实现的话，必须套用循环：
```Java
List<Integer> list = Arrays.asList(new Integer[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 });
List<Integer> rs = new ArrayList<Integer>();
for (Integer i : list) {
	if (i % 2 == 0) {
		rs.add(i * i);
	}
}
rs.sort(new Comparator<Integer>() {
	@Override
	public int compare(Integer o1, Integer o2) {
		return o2 - o1;
	}
});
```
不难看出，相比JavaScript，Java代码显得笨重且臃肿。Oracle明显也注意到了这一点，于是在Java8中加入了对集合相应的支持。Java8并未在原有的集合类中直接支持filter、map等操作的，而是引入了一个新的类：**Stream**。使用`Stream`对集合进行操作。例如：
```JavaScript
List<Integer> list = Arrays.asList(new Integer[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});
List<Integer> rs = list.stream().filter(i -> i % 2 == 0).map(i -> i * i).sorted((x,y) -> y - x).collect(Collectors.toList());
```
使用Java8新语法重构后的代码量接近JavaScript的代码，简洁性与可读性方面也有了很大的提高。当然，Java8支持的集合操作远比JavaScript多的多且更加强大。

## Stream

`Stream`提供对集合进行函数式编程操作的类。

Stream类和集合类都用于操作集合，但是Stream跟集合类存在很多不同点：

 * Stream并不是一个数据结构存储元素；它只是通过管道的方式将数据从数组、函数生成器、I/O通道中进行传输和操作；
 * 对Stream的操作并不会对产生Stream的源数据进行修改；
 * 懒惰取值（Laziness-seeking），很多Stream操作，例如filter、map、duplicate等并不会实时产生结果集。Stream的操作区分为两种：**中间操作**和**最终操作**，**中间操作**永远是懒惰取值的。这样做主要是为了性能优化。
 * Stream可能是无边界的。虽然集合是有大小限制，但Stream是不受大小限制的。短路操作，例如`limit(n)`或`findFirst()`可以从无边界的Stream中获取定长的数据。
 * 可消耗的。Stream的元素的在整个生命周期中只能被访问一次。类似于Iterator，如果想要重新访问Stream中的元素则需要重新生成Stream。

Stream可以通过多种方式获取，例如：

* Collection接口的子类可以通过`stream()`和`parallelStream()`获取；
* 数组可以通过`Arrays.stream(Object[])`获取；
* 可以通过`Stream.of(Object[])`、`IntStream.range(int, int)`或`Stream.iterate(Object,unaryOperator)`这个三个静态方法获取；
* 文件行可以通过`BufferedReader.lines()`获取；
* 指定路径的文件可以通过Files的方法获取；
* 随机数可以通过`Random.ints()`获取；
* 其他的跟获取Stream相关的方法还有`BitSet.stream`，`Pattern.splitAsStream(java.lang.Charsequence)`和`JarFile.stream（）`等。

## 流操作（Stream Operations）和管道（Pipelines）

流操作被划分为**中间操作**和**最终操作**，并且组合形成管道流。管道流由如下组合而成：数据源（例如集合，数组，函数生成器或I/O通道）；紧跟在数据源后面的是零或多个中间操作（例如Stream.filter或Stream.map）；最终操作紧跟在中间操作后面（例如Stream.forEach或Stream.reduce等）。
Stream operations are divided into intermediate and terminal operations, and are combined to form stream pipelines. A stream pipeline consists of a source (such as a Collection, an array, a generator function, or an I/O channel); followed by zero or more intermediate operations such as Stream.filter or Stream.map; and a terminal operation such as Stream.forEach or Stream.reduce.

Stream operations are divided into intermediate and terminal operations, and are combined to form stream pipelines. A stream pipeline consists of a source (such as a Collection, an array, a generator function, or an I/O channel); followed by zero or more intermediate operations such as Stream.filter or Stream.map; and a terminal operation such as Stream.forEach or Stream.reduce.

Intermediate operations return a new stream. They are always lazy; executing an intermediate operation such as filter() does not actually perform any filtering, but instead creates a new stream that, when traversed, contains the elements of the initial stream that match the given predicate. Traversal of the pipeline source does not begin until the terminal operation of the pipeline is executed.

Terminal operations, such as Stream.forEach or IntStream.sum, may traverse the stream to produce a result or a side-effect. After the terminal operation is performed, the stream pipeline is considered consumed, and can no longer be used; if you need to traverse the same data source again, you must return to the data source to get a new stream. In almost all cases, terminal operations are eager, completing their traversal of the data source and processing of the pipeline before returning. Only the terminal operations iterator() and spliterator() are not; these are provided as an "escape hatch" to enable arbitrary client-controlled pipeline traversals in the event that the existing operations are not sufficient to the task.

Processing streams lazily allows for significant efficiencies; in a pipeline such as the filter-map-sum example above, filtering, mapping, and summing can be fused into a single pass on the data, with minimal intermediate state. Laziness also allows avoiding examining all the data when it is not necessary; for operations such as "find the first string longer than 1000 characters", it is only necessary to examine just enough strings to find one that has the desired characteristics without examining all of the strings available from the source. (This behavior becomes even more important when the input stream is infinite and not merely large.)

Intermediate operations are further divided into stateless and stateful operations. Stateless operations, such as filter and map, retain no state from previously seen element when processing a new element -- each element can be processed independently of operations on other elements. Stateful operations, such as distinct and sorted, may incorporate state from previously seen elements when processing new elements.

Stateful operations may need to process the entire input before producing a result. For example, one cannot produce any results from sorting a stream until one has seen all elements of the stream. As a result, under parallel computation, some pipelines containing stateful intermediate operations may require multiple passes on the data or may need to buffer significant data. Pipelines containing exclusively stateless intermediate operations can be processed in a single pass, whether sequential or parallel, with minimal data buffering.

Further, some operations are deemed short-circuiting operations. An intermediate operation is short-circuiting if, when presented with infinite input, it may produce a finite stream as a result. A terminal operation is short-circuiting if, when presented with infinite input, it may terminate in finite time. Having a short-circuiting operation in the pipeline is a necessary, but not sufficient, condition for the processing of an infinite stream to terminate normally in finite time.

## 参考资料
 * 翻译自：http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html
