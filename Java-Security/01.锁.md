#01.锁

##不要在可重用的对象上加锁

不要在可重用的对象上加锁，如果你这样做了，可能导致死锁或其他不可预测的行为。

####不合规的代码（Boolean类型锁）

下面的代码在Boolean类型上加锁：

```Java
private final Boolean lock= Boolean.FALSE;
public void doSomething() {
  synchronized (lock) {
    // ...
  }
}
```

Boolean类型对象并不适合加锁，因为它只有两个值：`true`和`false`。在JVM中，Boolean类型的两个字面量值都分别都指向同一个共享对象。在这里例子中，lock指向JVM中的一个Boolean.FALSE实例，而这个实例的所有线程共享的。如果有其他的线程不注意地也使用了Boolean.FALSE进行加锁，就可能导致死锁或不可预测的行为。

####不合规的代码示例（Integer的自动装箱）

这个例子中的不合规代码在自动装箱的Integer类型上加锁：

```Java
private int = 0;
private final Integer lock = count; // Boxed primitive lock is shared
public void doSomething() {
  synchronized (lock) {
    count++;
    // ...
  }
}
```

自动装箱的Integer对象，在一定范围内是共享的（ 这个范围是-128到127），因此，这会导致跟Boolean常量一样的问题。JVM的常量池中缓存了Integer(-128)到Integer(127)这个范围的Integer对象，在这个范围内的自动装箱Integer对象，都是从这个常量池中共享这些对象。有一些JVM实现也允许大于这个范围的Integer常量池。所以，在自动装箱的对象上加锁是不安全的。而使用`new Integer(value)`创建的Integer实例对象是不共享的。**一般来说，在自动装箱的数据类型上加锁都是不可取和不安全的。**

####解决方案（Integer）

上面例子的解决方法就是在非装箱的Integer对象上加锁。如下面的代码所示：

```Java
private int count = 0;
private final Integer lock = new Integer(count);
 
public void doSomething() {
  synchronized (lock) {
    count++;
    // ...
  }
}
```
当使用构造方法时，会创建独立的Integer对象，而不会使用常量池中共享的Intege对象。这是一个可接受的解决方法，但这会导致维护问题，开发人员会错误地认为使用自动装箱的Integer也是可以的。更好的解决方法就是`new Object()`对象，最后一个例子会详细介绍。

####不合规的代码示例（new String("lock").intern()）

下面是一个不合规的代码示例：

```Java
private final String lock = new String("LOCK").intern();
public void doSomething() {
  synchronized (lock) {
    // ...
  }
}
```

Java API对java.lang.String类的inern()方法解释如下：

> 当调用`intern()`方法时，如果常量池中存在这个字符串对象，则会返回这个字符串对象，否则创建这个这个字符串对象，放置常量池并返回。

因此，`new String("lock").intern()`返回的对象有可能是JVM中共享的。即使这个字符串对象已经用`private`和`final`修饰，其他的线程仍然可以从JVM的常量池中共享这个对象。使用字符串常量也同样会有这个问题。

除此，恶意代码可能会利用这个漏洞进行攻击。详见：https://www.securecoding.cert.org/confluence/display/java/LCK00-J.+Use+private+final+lock+objects+to+synchronize+classes+that+may+interact+with+untrusted+code

Additionally, hostile code from any other package can exploit this vulnerability, if the class is accessible. See rule LCK00-J. Use private final lock objects to synchronize classes that may interact with untrusted code for more information.


Noncompliant Code Example (String Literal)
This noncompliant code example locks on a final String literal.
// This bug was found in jetty-6.1.3 BoundedThreadPool
private final String lock = "LOCK";
 
public void doSomething() {
  synchronized (lock) {
    // ...
  }
}
String literals are constant and are automatically interned. Consequently, this example suffers from the same pitfalls as the preceding noncompliant code example.
Compliant Solution (String Instance)
This compliant solution locks on a noninterned String instance.

```Java
private final String lock = new String("LOCK");
 
public void doSomething() {
  synchronized (lock) {
    // ...
  }
}
```

A String instance differs from a String literal. The instance has a unique reference and its own intrinsic lock that is distinct from other String object instances or literals. Nevertheless, a better approach is to synchronize on a private final lock object, as shown in the following compliant solution.
Compliant Solution (Private Final Lock Object)
This compliant solution synchronizes on a private final lock object. This is one of the few cases in which a java.lang.Object instance is useful.

```Java
private final Object lock = new Object();
 
public void doSomething() {
  synchronized (lock) {
    // ...
  }
}
```

For more information on using an Object as a lock, see rule LCK00-J. Use private final lock objects to synchronize classes that may interact with untrusted code.
Risk Assessment
A significant number of concurrency vulnerabilities arise from locking on the wrong kind of object. It is important to consider the properties of the lock object rather than simply scavenging for objects on which to synchronize.

----------


##另一个主题

 