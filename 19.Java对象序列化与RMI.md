#19.Java对象序列化与RMI

##19.1 Java对象序列化

对于一个存在于Java虚拟机中的对象来说，其内部的状态只保持在内存中。JVM停止之后，这些状态就丢失了。在很多应用场景中，很有必要将对象的内部状态持久化下来。

例如，用户A登陆了某系统，然后Tomcat被运维人员重启，而此时用户A的登陆凭证并没有因此丢失，这就是对象序列化发挥了作用：Tomcat在完成停止动作之前，将内部的登陆凭证数据序列化到硬盘中，然后在启动时重新读取这部分数据，登陆凭证并没有因容器重启而丢失。

###19.1.1 序列化

__对象序列化：将对象的状态信息转换为可以存储或传输的形式的过程。__

在Java中，并不是所有的对象都可以进行序列化，__只有实现`Serializable`接口的对象才可以进行序列化__。`Serializable`与`Cloneable`一样只是一个标识接口（markable interface），没有任何方法的定义，只标识实现此接口的对象拥有某些行为。

对象的序列化实际上通过类`ObjectOuputStream`类来完成。如：

```Java
public class serializableTest {
	@Test
	public void serialize() throws IOException, ClassNotFoundException {
		FileOutputStream fos = new FileOutputStream(new File("c://person.ser"));
		ObjectOutputStream oos = new ObjectOutputStream(fos);

		oos.writeObject(new Person("cokepluscarbon")); // 序列化person对象到硬盘中
		oos.close();
	}
}

class Person implements Serializable {
	private static final long serialVersionUID = 1L;
	private String name;

	public Person(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
```

需要注意：
 * 如果对象person没有实现`Serializable`接口，则会抛出`NotSerializableException`异常；
 * 序列化实际上是序列化整个对象图，例如Person对象引用了Country对象，则Country对象也需要实现`Serializable`接口；否则序列化过程失败；
 * 默认情况下，Java对象的非静态域才会参与序列化；如果想要排除某个域，可以使用注释`@transient`来排除，或使用域`serialPersistentFields`来指定需要序列化的域；

###19.1.2 反序列化

__反序列化：与序列化相反，发序列化用于将存储于介质的数据反序列化为对象。__

反序列化过程使用__ObjectInputStream__进行实现。例如将person.ser反序列化成person对象：

```Java
@Test
public void deserialize() throws IOException, ClassNotFoundException {
	FileInputStream fis = new FileInputStream(new File("c://person.ser"));
	ObjectInputStream ois = new ObjectInputStream(fis);

	Person person = (Person) ois.readObject();
	ois.close();

	System.out.println(person.getName()); // cokepluscarbon
}
```

###19.1.3 自定义对象序列化

在序列化过程中，如果序列化对象包含`readObject`方法，则使用对象的`readObject`方法进行序列化过程，反序列化过程亦是如此（对应的方法为writeObejct）。这个特征可以让开发人员对对象的序列化与反序列化过程进行细粒度的控制。

```
private void writeObject(ObjectOutputStream output) throws IOException {
	output.defaultWriteObject();
	output.writeUTF("Hello World");
}
private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException {
	input.defaultReadObject();
	String value = input.readUTF();
	System.out.println(value);
}
```

###19.1.4 序列化版本号

###19.1.5 序列号安全

##19.2 远程调用RMI

##19.3 参考资料
* 《Java深度历险》
* 《Java_编写高质量代码：改善Java程序的151个建议》
* http://stackoverflow.com/questions/1746550/purpose-of-serialization-in-webapplication
