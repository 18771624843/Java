#09.Java的volatile关键字

Java的**volatile**关键字用来标识让变量**像存储在主内存中一样** （The Java volatile keyword is used to mark a Java variable as "being stored in main memory". ）。更准确地说，被volatile声明的变量，它们的读操作都是从**主内存**中而不是**CPU缓存**中读取，同时，以及它们的写操作，都会同时写到**主内存**和**CPU缓存**中。

实际上，从Java 5开始，volatile关键字不仅仅只是保证变量从主内存中读取和写入。我会在接下来的章节进行详细讲解。

##volatile保证变量可见性（Java volatile Guarantees Variable Visibility）

Java的volatile关键字保证了**线程间变量的可见性**。这听起来似乎很抽象， 让我来解释一下。

在多线程的应用程序中，当多个线程对没有volatile关键字声明的变量进行操作时，基于性能考虑，每个线程都会从主内存中拷贝一份变量的值到CPU缓存里。如果你的计算器拥有多个CPU，那么每个线程都有可能使用不同的CPU运行。这意味着，每个线程都有可能拷贝一份数据到各自的CPU缓存中。这种情况如下图所示：

![enter image description here](http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png)

没有使用volatile声明的变量，将不能保证**JVM何时从主内存中读取数据到CPU缓存，以及何时从CPU缓冲中读取数据到内存**。让我解释一下这样会发生什么状况：



Imagine a situation in which two or more threads have access to a shared object which contains a counter variable declared like this:

public class SharedObject {

    public int counter = 0;

}
Thread 1 could read a shared counter variable with the value 0 into its CPU cache, increment it to 1 and not write the changed value back into main memory. Thread 2 could then read the same counter variable from main memory where the value of the variable is still 0, into its own CPU cache. Thread 2 could then also increment the counter to 1, and also not write it back to main memory. Thread 1 and Thread 2 are now practically out of sync. The real value of the shared counter variable should have been 2, but each of the threads has the value 1 for the variable in their CPU caches, and in main memory the value is still 0. It is a mess! Even if the threads eventually write their value for the shared counter variable back to main memory, the value will be wrong.

By declaring the shared counter variable volatile the JVM guarantees that every read of the variable will always be read from main memory, and that all writes to the variable will always be written back to main memory. Here is how the volatile declaration looks:

public class SharedObject {

    public volatile int counter = 0;

}
In some cases simply declaring a variable volatile may be enough to assure that multiple threads accessing the variable see the latest written value. I will get back to which cases volatile is sufficient later.

In the situation with the two threads reading and writing the same variable, simply declaring the variable volatile is not enough. Thread 1 may read the counter value 0 into a CPU register in CPU 1. At the same time (or right after) Thread 2 may read the counter value 0 into a CPU register in CPU 2. Both threads have read the value directly from main memory. Now both variables increase the value and writes the value back to main memory. They both increment their register version of counter to 1, and both write the value 1 back to main memory. The value should have been 2 after two increments.

The problem with multiple threads that do not see the latest value of a variable because that value has not yet been written back to main memory by another thread, is called a "visibility" problem. The updates of one thread are not visible to other threads.

##valatile的保证（The Java volatile Guarantee）

Since Java 5 the volatile keyword guarantees more than just the reading and writing of a variable from and to main memory. Actually, the volatile keyword guarantees this:

If Thread A writes to a volatile variable and Thread B subsequently reads the same volatile variable, then all variables visible to Thread A before writing the volatile variable, will also be visible to Thread B. 

The reading and writing instructions of volatile variables cannot be reordered by the JVM (the JVM may reorder instructions for performance reasons as long as the JVM detects no change in program behaviour from the reordering). Instructions before and after can be reordered, but the volatile read or write cannot be mixed with these instructions. Whatever instructions follow a read or write of a volatile variable are guaranteed to happen after the read or write.
Look at this example:

Thread A:
    sharedObject.nonVolatile = 123;
    sharedObject.counter     = sharedObject.counter + 1;

Thread B:
    int counter     = sharedObject.counter;
    int nonVolatile = sharedObject.nonVolatile;
Since Thread A writes the non-volatile variable sharedObject.nonVolatile before writing to the volatile sharedObject.counter, then both sharedObject.nonVolatile and sharedObject.counter are written to main memory.

Since Thread B starts by reading the volatile sharedObject.counter, then both the sharedObject.counter and sharedObject.nonVolatile are read in from main memory.

The reading and writing of the non-volatile variable cannot be reordered to happen before or after the reading and writing of the volatile variable.

##volatile足够了吗？（When is volatile Enough?）

As I have mentioned earlier, if two threads are both reading and writing to a shared variable, then using the volatile keyword for that is not enough. You need to use synchronization in that case to guarantee that the reading and writing of the variable is atomic.

But in case one thread reads and writes the value of a volatile variable, and other threads only read the variable, then the reading threads are guaranteed to see the latest value written to the volatile variable. Without making the variable volatile, this would not be guaranteed.

##volatile的性能考虑（Performance Considerations of volatile）

Reading and writing of volatile variables causes the variable to be read or written to main memory. Reading from and writing to main memory is more expensive than accessing the CPU cache. Accessing volatile variables also prevent instruction reordering which is anormal performance enhancement techqniqe. Thus, you should only use volatile variables when you really need to enforce visibility of variables.

