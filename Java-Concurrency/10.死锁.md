#10.死锁

死锁是指两个或多个线程等待其他处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。

例如，如果线程1持有锁A，但试图去获取锁B，而此时线程1持有锁B，却试图去获取锁A，这时死锁就发生了。线程1永远得不到锁B，线程2也永远得不到线程A，并且它们永远也不知道发生了什么事。为了获得彼此所持有的锁，它们将永远阻塞下去。这种情况就是一个死锁。

这种情况描述如下：

```
Thread 1  locks A, waits for B
Thread 2  locks B, waits for A
```

这里有一个TreeNode类的例子，它调用了不同实例的synchronized方法：

```Java
public class TreeNode {
  TreeNode parent   = null;  
  List     children = new ArrayList();

  public synchronized void addChild(TreeNode child){
    if(!this.children.contains(child)) {
      this.children.add(child);
      child.setParentOnly(this);
    }
  }
  
  public synchronized void addChildOnly(TreeNode child){
    if(!this.children.contains(child){
      this.children.add(child);
    }
  }
  
  public synchronized void setParent(TreeNode parent){
    this.parent = parent;
    parent.addChildOnly(this);
  }

  public synchronized void setParentOnly(TreeNode parent){
    this.parent = parent;
  }
}
```

 如果线程1调用`parent.addChild(child)`方法，而与此同时线程2调用`child.setParent(parent)`方法，两个线程中的parent和child都是同一个对象实例，此时死锁就发生了。

下面的伪代码说明了这个过程：

```
Thread 1: parent.addChild(child); //locks parent
          --> child.setParentOnly(parent);

Thread 2: child.setParent(parent); //locks child
          --> parent.addChildOnly()
```

首先线程1调用`parent.addChild(child)`方法，由于这个方法是同步的，所以线程1锁住了parent对象以防止其他线程访问。

然后线程2调用`child.setParent(parent)`方法，由于这个方法的同步的，所以线程2锁住了child对象以防止其他线程访问。

现在parent对象和child对象都分别被线程1和线程2锁住了。下一步，线程1试图调用`child.setParentOnly()`方法，但child方法已经被线程2锁住，所以这个方法会阻塞。线程2也试图调用`parent.addChildOnly()`方法，但parent对象此时已被线程1锁住，所以这个方法也会阻塞。现在两个线程都试图获取对方所持有的锁而进入阻塞状态。

Note: The two threads must call parent.addChild(child) and child.setParent(parent) at the same time as described above, and on the same two parent and child instances for a deadlock to occur. The code above may execute fine for a long time until all of a sudden it deadlocks.

The threads really need to take the locks *at the same time*. For instance, if thread 1 is a bit ahead of thread2, and thus locks both A and B, then thread 2 will be blocked already when trying to lock B. Then no deadlock occurs. Since thread scheduling often is unpredictable there is no way to predict *when* a deadlock occurs. Only that it *can* occur.


##More Complicated Deadlocks

Deadlock can also include more than two threads. This makes it harder to detect. Here is an example in which four threads have deadlocked:
```
Thread 1  locks A, waits for B
Thread 2  locks B, waits for C
Thread 3  locks C, waits for D
Thread 4  locks D, waits for A
```
Thread 1 waits for thread 2, thread 2 waits for thread 3, thread 3 waits for thread 4, and thread 4 waits for thread 1.

##Database Deadlocks

A more complicated situation in which deadlocks can occur, is a database transaction. A database transaction may consist of many SQL update requests. When a record is updated during a transaction, that record is locked for updates from other transactions, until the first transaction completes. Each update request within the same transaction may therefore lock some records in the database.

If multiple transactions are running at the same time that need to update the same records, there is a risk of them ending up in a deadlock.

For example

```
Transaction 1, request 1, locks record 1 for update
Transaction 2, request 1, locks record 2 for update
Transaction 1, request 2, tries to lock record 2 for update.
Transaction 2, request 2, tries to lock record 1 for update.
```

Since the locks are taken in different requests, and not all locks needed for a given transaction are known ahead of time, it is hard to detect or prevent deadlocks in database transactions.