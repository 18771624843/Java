#Java中的锁

**锁**跟**synchronized**的一样，是Java中的一种同步机制，但要比synchronized复杂得多。在Java 5之前，锁（以及其它更高级的线程同步机制）是由synchronized同步块的方式实现的，我们还不能完全摆脱synchronized关键字。

在Java 5的`java.util.concurrent.locks`包有多种锁的实现，因此，你并不需要自己去实现锁。当你仍然需要知道如何使用它们以及了解它们的实现原理。

##一个简单的锁（A Simple Lock）

让我们从一个简单的Java synchronized块开始：

```Java
public class Counter{

  private int count = 0;

  public int inc(){
    synchronized(this){
      return ++count;
    }
  }
}
```

注意`inc()`方法中的`synchronized(this)`块，这个块每次只允许一个线程进入执行`return ++count`代码。

Counter类可以用Lock类来实现同样的功能：

```Java
public class Counter{

  private Lock lock = new Lock();
  private int count = 0;

  public int inc(){
    lock.lock();
    int newCount = ++count;
    lock.unlock();
    return newCount;
  }
}
```

`lock()`方法会对Lock对象进行加锁，其他的线程都会在这个方法上阻塞，执行`unlock()`方法被调用。

下面是一个简单Lock类的实现：

```Java
public class Lock{
  private boolean isLocked = false;

  public synchronized void lock() throws InterruptedException{
    while(isLocked){
      wait();
    }
    isLocked = true;
  }

  public synchronized void unlock(){
    isLocked = false;
    notify();
  }
}
```

注意`while(isLocked)`这个循环，我们称之为**自旋锁**。自旋锁、wait方法和notify方法，我们在线程通信一文已经介绍过。当isLocked为true时，调用`lock()`方法的线程会嵌入等待状态。为了防止线程**虚假唤醒**（没调用notify()却无缘无故唤醒），将isLock作为循环的判断条件，如果线程虚假唤醒，则由于isLocked为true，则会再次调用`wait()`进入等待状态。当isLocked为false时，线程会离开while循环，将isLocked设置为true并锁住Lock对象。

当线程执行玩**临界区**（lock方法和unlock方法之间的代码）的代码后
，线程调用`unlock()`方法，将isLocked设置为`false`，同时调用`notify()`方法唤醒在`lock()`方法中陷入等待的其中一个线程。

##锁的可重入性（Lock Reentrance）

Java中的`synchronized`块是可重入的，意思是，当一个线程进入了一个`synchronized`块并持有该监听器对象的锁后，这个线程可以进入其他的基于这个监听器对象的`synchronized`块。例如下面这个例子：

```Java
public class Reentrant{
  public synchronized outer(){
    inner();
  }

  public synchronized inner(){
    //do something
  }
}
```

注意`outer()` 方法和`inner()`方法都用了 **synchronized** 关键字声明（等同于synchronized(this){}同步块）。如果一个线程成功进入`outer()` 方法后，也可以顺利成章地成功进入`inner()`方法，因为两个同步方法的监听器对象都是 **this** 对象。如果一个方法持有一个监听器对象的锁，则它可以任意进入基于这个监听器对象的同步块。这称之为**重入性**。

我们之前所实现的Lock类没不具有**可重入性**。如果我们将Reentrant类按照下面一样进行重构，调用`outer()`方法的线程将会陷入阻塞。

```Java
public class Reentrant2{
  Lock lock = new Lock();

  public outer(){
    lock.lock();
    inner();
    lock.unlock();
  }

  public synchronized inner(){
    lock.lock();
    //do something
    lock.unlock();
  }
}
```

调用`outer()`方法的线程首先获得Lock实例的锁，然后调用`inner()` 方法。在`inner()`方法内部会再次调用同一个Lock实例的`lock()`方法。由于此时isLocked为true，则它将进入`while(isLocked)`内部并调`this.wait()`而进入阻塞状态。

让我们在看下Lock类的实现：

```Java
public class Lock{

  boolean isLocked = false;

  public synchronized void lock() throws InterruptedException{
    while(isLocked){
      wait();
    }
    isLocked = true;
  }

  ...
}
```

问题在于while循环的判断，当同一个线程第一次调用`lock()`方法时，isLocked为true，当它再次调用`lock()` 方法时，则会进入while循环内部并调用wait()方法而阻塞。

为了让Lock类具有可重入性的特征，我们需要对它进行小小修改：

```Java
public class Lock{
  boolean isLocked = false;
  Thread  lockedBy = null;
  int     lockedCount = 0;

  public synchronized void lock() throws InterruptedException{
    Thread callingThread = Thread.currentThread();
    while(isLocked && lockedBy != callingThread){
      wait();
    }
    isLocked = true;
    lockedCount++;
    lockedBy = callingThread;
  }


  public synchronized void unlock(){
    if(Thread.curentThread() == this.lockedBy){
      lockedCount--;

      if(lockedCount == 0){
        isLocked = false;
        notify();
      }
    }
  }

  ...
}
```



Notice how the while loop (spin lock) now also takes the thread that locked the Lock instance into consideration. If either the lock is unlocked (isLocked = false) or the calling thread is the thread that locked the Lock instance, the while loop will not execute, and the thread calling lock() will be allowed to exit the method.

Additionally, we need to count the number of times the lock has been locked by the same thread. Otherwise, a single call to unlock() will unlock the lock, even if the lock has been locked multiple times. We don't want the lock to be unloced until the thread that locked it, has executed the same amount of unlock() calls as lock() calls.

The Lock class is now reentrant.

## 公平锁（Lock Fairness）

Java's synchronized blocks makes no guarantees about the sequence in which threads trying to enter them are granted access. Therefore, if many threads are constantly competing for access to the same synchronized block, there is a risk that one or more of the threads are never granted access - that access is always granted to other threads. This is called starvation. To avoid this a Lock should be fair. Since the Lock implementations shown in this text uses synchronized blocks internally, they do not guarantee fairness. Starvation and fairness are discussed in more detail in the text Starvation and Fairness.

Calling unlock() From a finally-clause

When guarding a critical section with a Lock, and the critical section may throw exceptions, it is important to call the unlock() method from inside a finally-clause. Doing so makes sure that the Lock is unlocked so other threads can lock it. Here is an example:

lock.lock();
try{
  //do critical section code, which may throw exception
} finally {
  lock.unlock();
}
This little construct makes sure that the Lock is unlocked in case an exception is thrown from the code in the critical section. If unlock() was not called from inside a finally-clause, and an exception was thrown from the critical section, the Lock would remain locked forever, causing all threads calling lock() on that Lock instance to halt indefinately.